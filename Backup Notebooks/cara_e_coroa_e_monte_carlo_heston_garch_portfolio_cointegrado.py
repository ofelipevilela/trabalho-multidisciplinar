# -*- coding: utf-8 -*-
"""Cara e coroa e Monte Carlo - Heston - Garch - Portfolio Cointegrado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T2c1NQPmU_0rNEVJG03qPxAzGTV6V7Gq

# TRABALHO MULTIDISCIPLINAR (MAC035-2025.1)

##  TEMA: MERCADO FINANCEIRO: ALEATORIO OU DETERMINADO?

- GRUPO:

  FELIPE

  FELIX

  WILLIAM

### Trading com cara e coroa e Monte Carlo
"""

!pip install yfinance -q

# Carregando as bibliotecas

from datetime import datetime
import random
import yfinance as yf
import pandas as pd
import numpy as np
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

import sys
import time

# PARÂMETROS DA SIMULAÇÃO
stock_symbol = "^GSPC"    #Indice S&P500
start_date = "2010-01-01"
end_date = "2025-01-01"
num_sim = 1000      # Número de simulações (vidas financeiras)
op_cost = 0.001     # Custo operacional de 0.1% por transação


# 2. Obtenção dos Dados
print(f"Baixando dados para {stock_symbol} de {start_date} até {end_date}...")
# Use auto_adjust=False to get the original columns, including 'Adj Close' if available
data = yf.download(stock_symbol, start=start_date, end=end_date, progress=False, auto_adjust=False)

# Check for 'Adj Close' in the multi-level columns
adj_close_col = ('Adj Close', stock_symbol)
close_col = ('Close', stock_symbol)

if adj_close_col in data.columns:
    daily_market_returns = data[adj_close_col].pct_change().dropna()
else:
    # If 'Adj Close' is not found, use 'Close'
    if close_col in data.columns:
        print(f"Warning: ('Adj Close', '{stock_symbol}') not found, using ('Close', '{stock_symbol}').")
        daily_market_returns = data[close_col].pct_change().dropna()
    else:
        # Handle case where neither 'Adj Close' nor 'Close' is found
        print(f"Error: Neither 'Adj Close' nor 'Close' found for {stock_symbol}. Cannot calculate returns.")
        daily_market_returns = pd.Series([], dtype=float) # Create an empty series


print("Dados carregados e processados.")


# 3. Execução da Simulação de Monte Carlo
print(f"\nIniciando {num_sim} simulações da estratégia 'Cara ou Coroa'...")

if not daily_market_returns.empty:
    # Gera todos os sinais aleatórios (-1 para Venda, +1 para Compra) de uma vez
    random_signals = np.random.choice([-1, 1], size=(len(daily_market_returns), num_sim))

    # Calcula os retornos diários da estratégia (já líquidos de custo)
    # Para este modelo, o custo é diário, pois a posição é sempre reafirmada.
    strategy_daily_returns = (random_signals * daily_market_returns.values[:, np.newaxis]) - op_cost

    # --- CORREÇÃO PRINCIPAL ---
    # Calcula a curva de patrimônio usando o PRODUTO CUMULATIVO (cumprod).
    # (1 + retorno diário) é o fator de multiplicação do capital no dia.
    # O resultado é o valor do patrimônio, assumindo que começou com 1.
    equity_curves_df = (1 + pd.DataFrame(strategy_daily_returns, index=daily_market_returns.index)).cumprod()

    print("Simulações concluídas.")


    # 4. Cálculo das Estatísticas Finais
    # Para obter o retorno total, pegamos o valor final do patrimônio e subtraímos 1.
    final_total_returns = equity_curves_df.iloc[-1] - 1

    print("\n--- Estatísticas Corrigidas da Simulação ---")
    print(f"Para o ativo {stock_symbol}, com base em {num_sim} simulações:")
    print("---------------------------------------------------------")
    print(f"Retorno total médio: {final_total_returns.mean() * 100:.2f}%")
    print(f"Retorno total máximo: {final_total_returns.max() * 100:.2f}%")
    print(f"Retorno total mínimo: {final_total_returns.min() * 100:.2f}%")
    print()
    print("Com base nos resultados finais:")
    print(f"    50% de chance de um retorno total maior que: {final_total_returns.median() * 100:.2f}% (Mediana)")
    print(f"    25% de chance de um retorno total maior que: {final_total_returns.quantile(0.75) * 100:.2f}% (3º Quartil)")
    print(f"     5% de chance de um retorno total maior que: {final_total_returns.quantile(0.95) * 100:.2f}% (Percentil 95)")
    print("---------------------------------------------------------")


    # 5. Visualização dos Resultados
    print("\nGerando gráfico das simulações...")
    # Converte o valor do patrimônio em retorno percentual para o gráfico
    return_curves_df = (equity_curves_df - 1) * 100

    plt.style.use('seaborn-v0_8-darkgrid')
    plt.figure(figsize=(14, 8))
    plt.plot(return_curves_df, linewidth=0.5, alpha=0.7)

    plt.title(f"Simulação 'Cara & Coroa' - {num_sim} Trajetórias para S&P500", fontsize=16)
    plt.xlabel("Tempo", fontsize=12)
    plt.ylabel("Retorno Total Acumulado (%)", fontsize=12)
    plt.axhline(0, color='black', linestyle='--', linewidth=1)
    plt.ylim(bottom=-100) # Define o limite inferior do eixo Y em -100%
    plt.grid(True)
    plt.show()
else:
    print("Não foi possível executar a simulação devido à falta de dados de retorno.")

"""### METODO DE HESTON

![image.png](data:image/png;base64,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)

κ(kappa) é a velocidade de reversão da volatilidade: Modela a tendência da volatilidade de voltar a um nível normal

θ (theta)  é a volatilidade média de longo prazo: O "nível normal" para o qual a volatilidade tende a retornar

σ (sigma) é a volatilidade da volatilidade (vol of vol) : captura o quão instável é a própria volatilidade),

W1(t) e W2(t) são movimentos brownianos correlacionados com correlação ρ(rho). Essa correlação é tipicamente negativa: quando o preço do ativo cai, a volatilidade tende a subir (o mercado fica com medo)

Valores calibrado para o SP500

κ = 2.5 (valor central entre 2 e 3)

θ (theta) = 0.025 (variância de longo prazo, correspondendo a uma volatilidade de sqrt(0.025) ≈ 15.8%, que está no centro da faixa de 14-17%)

σ (sigma) = 0.55 (valor central entre 0.4 e 0.7)

ρ (rho) = -0.5 (valor central entre -0.4 e -0.6)

v₀ (variância inicial) = 0.03 (valor central entre 2% e 4%)

### TESTE COM AÇOES: NVIDIA, INTEL E AMD
"""

#Coleta de Dados para Todos os Ativos
print("Iniciando coleta de dados...")
tickers = ['^GSPC', 'NVDA', 'AMD', 'INTC', '^VIX']
start_date = "2010-01-01"
end_date = "2024-05-30"

all_data = yf.download(tickers, start=start_date, end=end_date, progress=False, auto_adjust=False)

#Prepara o DataFrame final com os retornos e o VIX
df = pd.DataFrame()
for ticker in ['^GSPC', 'NVDA', 'AMD', 'INTC']:
    df[f'Returns_{ticker}'] = all_data['Close'][ticker].pct_change()

df['VIX_Close'] = all_data['Close']['^VIX']   # Puxa o VIX para comparar no futuro
df = df.dropna()
print("Dados para todos os ativos carregados e alinhados.")

#Função de Simulação do Modelo Heston
#Gera diversas iteracoes para obter uma uma media de vol futura
def simulate_heston_paths(S0, v0, r, kappa, theta, sigma, rho, T, M, N):
    dt = T / M
    prices = np.zeros((M + 1, N))
    variances = np.zeros((M + 1, N))
    prices[0], variances[0] = S0, v0 # preco e vol atual

    Z1 = np.random.normal(size=(M, N))  # choque de aletoriedade
    Z2 = np.random.normal(size=(M, N))
    dW1 = np.sqrt(dt) * Z1
    dW2 = np.sqrt(dt) * (rho * Z1 + np.sqrt(1 - rho**2) * Z2)

    epsilon = 1e-10
    #itera para calcular preco e volatilidade
    for t in range(1, M + 1):
        # a variancia tende a voltar pra média (theta) e sofre uns choques aleatorios
        variances[t] = (variances[t-1] + kappa * (theta - np.maximum(variances[t-1], 0)) * dt +
                        sigma * np.sqrt(np.maximum(variances[t-1], 0) + epsilon) * dW2[t-1])
        # o preco rende uma taxinha 'r' e também sofre os choques aleatórios com base na vol
        prices[t] = prices[t-1] * np.exp((r - 0.5 * np.maximum(variances[t-1], 0)) * dt + np.sqrt(np.maximum(variances[t-1], 0) + epsilon) * dW1[t-1])
    return prices, variances

#Função de Backtest
def run_heston_backtest(returns_series, heston_params, sim_params, strategy_mode, op_cost, vix_series=None):
    kappa, theta, sigma, rho, r = heston_params
    N, T, M = sim_params
    historical_vol_50d = returns_series.rolling(window=50).std() * np.sqrt(252) * 100  #media de volatidade dos ultimos 50 dias para acoes

    signals = []

    for i in range(len(returns_series)):
        #Pego a volatilidade dos últimos 22 dias (1 mês de pregão) pra ter um valor inicial.
        if i < 22:
            v0 = theta
        else:
            historical_returns_v0 = returns_series.iloc[i-22:i]
            if len(historical_returns_v0.dropna()) >= 22:
                 v0 = (historical_returns_v0.std() * np.sqrt(252))**2
            else:
                 v0 = theta

        _, simulated_variances = simulate_heston_paths(1, v0, r, kappa, theta, sigma, rho, T, M, N) # Roda o Heston pra prever a volatilidade futura
        mean_future_variance = np.mean(simulated_variances[-1])
        heston_forecast_annualized = np.sqrt(mean_future_variance) * 100 #gera a media da volatilidade %

        signal = 1 # começa querendo comprar.
        if strategy_mode == 'vs_vix': #para indices
            vix_market = vix_series.iloc[i]
            VIX_CRISE = 40.0
            # Se a nossa previsão de vol for maior que o VIX, ou se o VIX já explodiu, melhor vender
            if (heston_forecast_annualized > vix_market) or (vix_market > VIX_CRISE):
                signal = -1
        elif strategy_mode == 'vs_historical_vol': # para acoes
            hist_vol_market = historical_vol_50d.iloc[i]
            if not np.isnan(hist_vol_market) and heston_forecast_annualized < hist_vol_market:
                signal = -1
        signals.append(signal)

    signals_s = pd.Series(signals, index=returns_series.index)
    trades = signals_s.diff().ne(0) # dias operados
    trades.iloc[0] = True
    daily_costs = trades * op_cost # custo total
    strategy_returns = (signals_s * returns_series.shift(-1)) - daily_costs # retorno final = sinal * resultado - custo

    equity_curve = (1 + strategy_returns).cumprod() - 1
    return equity_curve, strategy_returns

#Execução Principal
print("\nDefinindo parâmetros e rodando simulações...")
# parametros especificos de cada ativo [ kappa, theta, sigma, rho ]
asset_specific_params = {
    '^GSPC': [2.5, 0.025, 0.55, -0.5],
    'NVDA':  [2.5, 0.25,  0.9,  -0.75],
    'INTC':  [4.0, 0.12,  0.4,  -0.55],
    'AMD':   [3.0, 0.18,  0.7,  -0.70]
}
op_cost_net = 0.001
r = 0.02
sim_params = [1000, 30/252, 30] #1000 simulações, pra 30 dias no futuro, com 30 passos

asset_tickers = ['^GSPC', 'NVDA', 'AMD', 'INTC']
results_net = {}
daily_returns_net = {}

# Loop final que passa por cada ativo e roda o backtest
for ticker in asset_tickers:
    print(f"\n--- Executando backtest para: {ticker} ---")
    heston_params = asset_specific_params[ticker] + [r]
    returns_col = f'Returns_{ticker}'

    # A estratégia pro S&P 500 usa o VIX. Para os outros, a media da vol 50 dias
    strategy_mode = 'vs_vix' if ticker == '^GSPC' else 'vs_historical_vol'
    vix_input = df['VIX_Close'] if ticker == '^GSPC' else None

    equity_curve, daily_returns = run_heston_backtest(df[returns_col], heston_params, sim_params,
                                                      strategy_mode, op_cost=op_cost_net, vix_series=vix_input)
    results_net[ticker] = equity_curve
    daily_returns_net[ticker] = daily_returns

print("\nTodos os backtests foram concluídos!")


#Consolidação e Visualização dos Resultados
results_df_net = pd.DataFrame({k: v for k, v in results_net.items() if v is not None}).dropna()


#Gráfico 1: Curva de Patrimônio Comparativa (Líquido)
plt.style.use('seaborn-v0_8-darkgrid')
plt.figure(figsize=(16, 9))

for ticker in results_df_net.columns:
    label = f'Heston vs. VIX ({ticker})' if ticker == '^GSPC' else f'Heston vs. Hist. Vol ({ticker})'
    plt.plot((results_df_net[ticker] * 100), label=label, linewidth=2)


plt.title('Comparativo de Desempenho com Estratégias Adaptativas (Heston vs. Vol)', fontsize=16)
plt.xlabel('Data', fontsize=12)
plt.ylabel('Retorno Acumulado (%)', fontsize=12)
plt.legend(fontsize=12)
plt.grid(True)
plt.show()

# Gráficos de Desempenho Individual por Ativo (Líquido)
print("\n--- Gerando Gráficos de Desempenho Individual ---")
for ticker in results_df_net.columns:
    plt.figure(figsize=(14, 7))

    label_net = f'Heston vs. VIX ({ticker})' if ticker == '^GSPC' else f'Heston vs. Hist. Vol ({ticker})'
    if ticker in results_df_net.columns and not results_df_net[ticker].dropna().empty:
        plt.plot((results_df_net[ticker].dropna() * 100), label=label_net, color='royalblue', linewidth=2)


    plt.title(f'Desempenho da Estratégia Heston para {ticker}', fontsize=16)
    plt.xlabel('Data', fontsize=12)
    plt.ylabel('Retorno Acumulado (%)', fontsize=12)
    plt.legend(fontsize=12)
    plt.grid(True)
    plt.axhline(0, color='grey', linewidth=0.8) # Adiciona linha no zero
    plt.show()


#Análise de Janelas Deslizantes (Rolling Windows)
print("\n Retorno Médio para Prazos Fixos (Análise de Janelas Deslizantes) ")

# Define as janelas em dias de negociação (aproximadamente 252 por ano)
window_sizes = {
    '1 Ano': 252,
    '3 Anos': 252 * 3,
    '5 Anos': 252 * 5,
    '10 Anos': 252 * 10
}

# Itera sobre cada ativo para calcular e mostrar os resultados
for ticker in asset_tickers:
    print(f"\nAtivo: {ticker}")

    # Pega a série de retornos diários para o ticker atual
    strategy_daily_returns = daily_returns_net[ticker].dropna()
    daily_factors = 1 + strategy_daily_returns

    # Calcula o retorno para cada janela de tempo
    for name, window in window_sizes.items():
        if len(daily_factors) > window:
            # A função .rolling().apply(np.prod) calcula o produto acumulado dentro da janela
            rolling_total_returns = daily_factors.rolling(window=window).apply(np.prod, raw=True) - 1

            # Calcula a média de todos os retornos de período encontrados
            average_return = rolling_total_returns.mean() * 100
            print(f"  Retorno Médio ({name}): {average_return:.2f}%")
        else:
            print(f"  Retorno Médio ({name}): Não há dados suficientes para uma janela completa.")

# Corrected code to access the column
aux = results_df['^GSPC']

# You can display the result to see the column data
display(aux)

"""## Modelo GARCH

### Dados
"""

import yfinance as yf
import pandas as pd
import numpy as np

# Definindo o período do backtest
start_date = "2010-01-01"
end_date = "2024-06-30"

# Baixa os dados do S&P 500
sp500 = yf.download('^GSPC', start=start_date, end=end_date)

# Calcula os retornos logarítmicos diários
# Adjust for multi-level columns and get Log_Returns
if ('Adj Close', '^GSPC') in sp500.columns:
    sp500['Log_Returns'] = np.log(sp500[('Adj Close', '^GSPC')] / sp500[('Adj Close', '^GSPC')].shift(1))
else:
    print("Warning: ('Adj Close', '^GSPC') not found for S&P 500, using ('Close', '^GSPC').")
    sp500['Log_Returns'] = np.log(sp500[('Close', '^GSPC')] / sp500[('Close', '^GSPC')].shift(1))


# Baixa os dados do VIX
vix = yf.download('^VIX', start=start_date, end=end_date)

# Cria DataFrame unificado
# Adjust for multi-level columns and get VIX_Close
if ('Adj Close', '^VIX') in vix.columns:
    vix_close = vix[('Adj Close', '^VIX')] # Get the Series directly
else:
     print("Warning: ('Adj Close', '^VIX') not found for VIX, using ('Close', '^VIX').")
     vix_close = vix[('Close', '^VIX')] # Get the Series directly


df = pd.DataFrame({
    'SP500_Log_Returns': sp500['Log_Returns'],
    'VIX_Close': vix_close
})

# Remove linhas com dados faltantes
df.dropna(inplace=True)

# Visualiza as 5 primeiras linhas
print("✅ Dados coletados e preparados:")
display(df.head())

"""### Modelo Arch

"""

pip install arch

from arch import arch_model

# Lista para armazenar as previsões de volatilidade
garch_forecasts = []

# Janela de histórico para treinar o modelo GARCH
window_size = 250  # aproximadamente 1 ano de pregão

# Vamos prever a volatilidade para o período de 2021
df_garch_backtest = df.loc[start_date:end_date].copy()

print("\n🔄 Estimando volatilidade com GARCH(1,1)...")

for i in range(len(df_garch_backtest)):
    end_idx = df_garch_backtest.index[i]
    start_idx = df_garch_backtest.index.get_loc(end_idx) - window_size
    if start_idx < 0:
        garch_forecasts.append(np.nan)
        continue

    # Seleciona a janela de treinamento
    train_returns = df_garch_backtest['SP500_Log_Returns'].iloc[start_idx:start_idx + window_size]

    # Ajusta o modelo GARCH(1,1)
    model = arch_model(train_returns, vol='GARCH', p=1, q=1, rescale=False)
    fitted_model = model.fit(disp='off')

    # Previsão de 1 passo à frente (variância)
    forecast = fitted_model.forecast(horizon=1)
    variance_forecast = forecast.variance.values[-1, 0]

    # Volatilidade anualizada (%)
    annualized_vol = np.sqrt(variance_forecast) * np.sqrt(252) * 100
    garch_forecasts.append(annualized_vol)

# Adiciona a coluna com as previsões ao DataFrame
df_garch_backtest['GARCH_Annualized'] = garch_forecasts

print("✅ Previsões GARCH adicionadas ao DataFrame.")
df_garch_backtest[['SP500_Log_Returns', 'VIX_Close', 'GARCH_Annualized']].dropna().head()

"""### Geração de Sinais"""

# Inicializa a lista de sinais
signals = []

# Geração dos sinais com base na comparação GARCH vs VIX
for i in range(len(df_garch_backtest)):
    garch_vol = df_garch_backtest['GARCH_Annualized'].iloc[i]
    vix_vol = df_garch_backtest['VIX_Close'].iloc[i]

    if np.isnan(garch_vol) or np.isnan(vix_vol):
        signals.append(np.nan)
        continue

    # Estratégia: Comprar quando VIX > GARCH previsto
    signal = 1 if vix_vol > garch_vol else -1
    signals.append(signal)

# Adiciona a coluna de sinais ao DataFrame
df_garch_backtest['GARCH_Signal'] = signals

# Visualiza os primeiros sinais
print("✅ Sinais gerados com base na comparação GARCH vs. VIX:")
df_garch_backtest[['GARCH_Annualized', 'VIX_Close', 'GARCH_Signal']].dropna().head()

"""###Aplicação de Sinais

"""

# Aplica o sinal ao retorno do dia seguinte (shift -1)
df_garch_backtest['GARCH_Strategy_Return'] = df_garch_backtest['GARCH_Signal'] * df_garch_backtest['SP500_Log_Returns'].shift(-1)

# Calcula o retorno acumulado da estratégia
df_garch_backtest['GARCH_Equity_Curve'] = (1 + df_garch_backtest['GARCH_Strategy_Return']).cumprod() - 1

# Visualiza o início
print("✅ Retorno da estratégia calculado:")
df_garch_backtest[['GARCH_Strategy_Return', 'GARCH_Equity_Curve']].dropna().head()

"""### Visualizações de resultados"""

import matplotlib.pyplot as plt

plt.style.use('seaborn-v0_8-darkgrid')
plt.figure(figsize=(14, 8))

# Plot da estratégia
plt.plot(df_garch_backtest['GARCH_Equity_Curve'] * 100, label='Estratégia GARCH vs. VIX', linewidth=2.5)

# Títulos e legendas
plt.title('Desempenho da Estratégia GARCH (Ano 2021)', fontsize=16)
plt.xlabel('Data', fontsize=12)
plt.ylabel('Retorno Acumulado (%)', fontsize=12)
plt.legend(fontsize=12)
plt.grid(True)
plt.tight_layout()
plt.show()

# Imprime o retorno total acumulado da estratégia GARCH
# Use iloc[-2] to get the last valid cumulative return before the potential NaN from shift(-1)
total_return_garch = df_garch_backtest['GARCH_Equity_Curve'].iloc[-2] * 100
print(f"Retorno Total Acumulado da Estratégia GARCH vs. VIX em 2021: {total_return_garch:.2f}%")

# ==============================================================================
# Bloco de Código - Estratégias GARCH Adaptativas com Parâmetros Individualizados
# ==============================================================================

# 1. Importação de Bibliotecas
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from arch import arch_model # Import the arch library
from arch.univariate.base import ConvergenceWarning # Import ConvergenceWarning
import warnings # Import warnings

# 2. Coleta de Dados para Todos os Ativos
print("Iniciando coleta de dados...")
# Lista de todos os tickers que precisamos
tickers = ['^GSPC', 'NVDA', 'AMD', 'INTC', '^VIX']
start_date = "2010-01-01"
end_date = "2024-12-30"

# Baixa todos os dados de uma vez
# Use auto_adjust=False to keep 'Adj Close' if available
all_data = yf.download(tickers, start=start_date, end=end_date, progress=False, auto_adjust=False)

# Prepara o DataFrame final com os retornos e o VIX
df = pd.DataFrame()
for ticker in ['^GSPC', 'NVDA', 'AMD', 'INTC']:
    # Access 'Adj Close' using the MultiIndex tuple
    adj_close_col = ('Adj Close', ticker)
    close_col = ('Close', ticker)

    if adj_close_col in all_data.columns:
        df[f'Returns_{ticker}'] = all_data[adj_close_col].pct_change()
    elif close_col in all_data.columns:
        print(f"Warning: ('Adj Close', '{ticker}') not found, using ('Close', '{ticker}').")
        df[f'Returns_{ticker}'] = all_data[close_col].pct_change()
    else:
        print(f"Error: No price data found for {ticker}. Skipping.")
        continue


# Access 'Adj Close' for VIX using the MultiIndex tuple
vix_adj_close_col = ('Adj Close', '^VIX')
vix_close_col = ('Close', '^VIX')

if vix_adj_close_col in all_data.columns:
    df['VIX_Close'] = all_data[vix_adj_close_col]
elif vix_close_col in all_data.columns:
     print("Warning: ('Adj Close', '^VIX') not found for VIX, using ('Close', '^VIX').")
     df['VIX_Close'] = all_data[vix_close_col]
else:
    print("Error: No price data found for ^VIX. VIX analysis will not be possible.")


df = df.dropna()
print("Dados para todos os ativos carregados e alinhados.")


# 3. Função para Rodar o Backtest com Modelo GARCH
def run_garch_backtest(returns_series, vix_series=None):
    """
    Executa o backtest da estratégia GARCH vs. VIX (para ^GSPC) ou GARCH vs. Volatilidade Histórica (para outros ativos).
    """
    window_size = 250 # aproximadamente 1 ano de pregão

    garch_forecasts = []
    signals = []

    print("🔄 Estimando volatilidade com GARCH(1,1) e gerando sinais...")

    for i in range(len(returns_series)):
        end_idx = returns_series.index[i]
        start_idx = returns_series.index.get_loc(end_idx) - window_size

        if start_idx < 0:
            garch_forecasts.append(np.nan)
            signals.append(np.nan)
            continue

        # Seleciona a janela de treinamento
        train_returns = returns_series.iloc[start_idx:start_idx + window_size].dropna() # Drop NaNs in training window

        if len(train_returns) < 100: # Ensure sufficient data points for fitting
             garch_forecasts.append(np.nan)
             signals.append(np.nan)
             continue


        # Ajusta o modelo GARCH(1,1)
        try:
            model = arch_model(train_returns, vol='GARCH', p=1, q=1, rescale=False)
            # Catch ConvergenceWarning specifically
            with warnings.catch_warnings():
                warnings.filterwarnings("ignore", category=ConvergenceWarning)
                fitted_model = model.fit(disp='off')


            # Previsão de 1 passo à frente (variância)
            forecast = fitted_model.forecast(horizon=1)
            variance_forecast = forecast.variance.values[-1, 0]

            # Volatilidade anualizada (%)
            annualized_vol = np.sqrt(variance_forecast) * np.sqrt(252) * 100
            garch_forecasts.append(annualized_vol)

            # --- LÓGICA CONDICIONAL DA ESTRATÉGIA ---
            signal = -1 # Sinal padrão é vender/neutro (corrigido para seguir a lógica anterior)

            if vix_series is not None: # Estratégia para S&P 500 (GARCH vs VIX)
                vix_market = vix_series.iloc[i]
                if np.isnan(vix_market):
                    signal = np.nan
                elif vix_market > annualized_vol:
                    signal = 1 # Comprar quando VIX > GARCH previsto
                else:
                    signal = -1 # Vender/Neutro quando VIX <= GARCH previsto
            else: # Estratégia para outros ativos (GARCH vs Volatilidade Histórica)
                # Calcula volatilidade histórica móvel (50 dias)
                hist_vol_market = returns_series.iloc[max(0, i-50):i].std() * np.sqrt(252) * 100
                if np.isnan(hist_vol_market):
                    signal = np.nan
                elif annualized_vol < hist_vol_market:
                     signal = 1 # Comprar quando GARCH previsto < Vol Histórica
                else:
                     signal = -1 # Vender/Neutro quando GARCH previsto >= Vol Histórica


            signals.append(signal)

        except Exception as e:
            # print(f"Erro na simulação GARCH no dia {returns_series.index[i]}: {e}")
            garch_forecasts.append(np.nan)
            signals.append(np.nan)


    # Calcula e retorna a curva de patrimônio
    signals_series = pd.Series(signals, index=returns_series.index)
    strategy_returns = signals_series * returns_series.shift(-1)
    equity_curve = (1 + strategy_returns).cumprod() - 1
    return equity_curve, pd.Series(garch_forecasts, index=returns_series.index)


# 4. Execução Principal com Lógica Adaptativa e Parâmetros Individualizados

asset_tickers = ['^GSPC', 'NVDA', 'AMD', 'INTC']
results = {}
garch_vol_results = {}


# Loop para rodar o backtest em cada ativo com a estratégia e parâmetros corretos
for ticker in asset_tickers:
    print(f"\n--- Executando backtest para: {ticker} ---")
    returns_col = f'Returns_{ticker}'

    if ticker == '^GSPC':
        print(f"Usando estratégia: GARCH vs. VIX")
        if 'VIX_Close' in df.columns:
            equity_curve, garch_vols = run_garch_backtest(df[returns_col], vix_series=df['VIX_Close'])
            results[ticker] = equity_curve
            garch_vol_results[ticker] = garch_vols
        else:
            print(f"Skipping {ticker} backtest as VIX data is not available.")
    else:
        print(f"Usando estratégia: GARCH vs. Volatilidade Histórica")
        equity_curve, garch_vols = run_garch_backtest(df[returns_col]) # No VIX series for other assets
        results[ticker] = equity_curve
        garch_vol_results[ticker] = garch_vols


print("\nTodos os backtests foram concluídos!")

# 5. Consolidação e Visualização dos Resultados
results_df = pd.DataFrame(results) # Keep NaNs initially for correct plotting
garch_vol_df = pd.DataFrame(garch_vol_results)


plt.style.use('seaborn-v0_8-darkgrid')
plt.figure(figsize=(16, 9))

# Plot dos resultados com legendas claras
for ticker in results_df.columns:
    label = f'GARCH vs. VIX ({ticker})' if ticker == '^GSPC' else f'GARCH vs. Hist. Vol ({ticker})'
    # Ensure there's data to plot before plotting
    if not results_df[ticker].dropna().empty:
      plt.plot((results_df[ticker].dropna() * 100), label=label, linewidth=2) # Drop NaNs for plotting
    else:
      print(f"No data to plot for {ticker} equity curve.")


plt.title('Comparativo de Desempenho com Estratégias Baseadas em GARCH', fontsize=16)
plt.xlabel('Data', fontsize=12)
plt.ylabel('Retorno Acumulado (%)', fontsize=12)
plt.legend(fontsize=12)
plt.grid(True)
plt.show()

# --- NOVO BLOCO: Gráficos de Desempenho Individual por Ativo (GARCH) ---
print("\n--- Gerando Gráficos de Desempenho Individual (GARCH) ---")
for ticker in results_df.columns:
    # Cria uma nova figura para cada gráfico, garantindo que sejam separados
    plt.figure(figsize=(14, 7))

    label = f'GARCH vs. VIX ({ticker})' if ticker == '^GSPC' else f'GARCH vs. Hist. Vol ({ticker})'
    # Ensure there's data to plot before plotting
    if not results_df[ticker].dropna().empty:
        plt.plot((results_df[ticker].dropna() * 100), label=label, color='royalblue')
        plt.title(f'Desempenho da Estratégia GARCH para {ticker}', fontsize=16)
        plt.xlabel('Data', fontsize=12)
        plt.ylabel('Retorno Acumulado (%)', fontsize=12)
        plt.legend(fontsize=12)
        plt.grid(True)
        plt.axhline(0, color='grey', linewidth=0.8) # Adiciona linha no zero
        plt.show()
    else:
        print(f"No data to plot for {ticker} individual equity curve.")


# --- Métricas Finais ---
print("\n--- Resultado Final do Retorno Acumulado ---")
# Calculate final return by taking the last non-NaN value for each ticker
final_returns_net = pd.Series({ticker: results_df[ticker].dropna().iloc[-1] * 100 if not results_df[ticker].dropna().empty else np.nan for ticker in results_df.columns}).dropna()


for ticker in final_returns_net.index:
    final_return = final_returns_net[ticker]
    print(f"Ativo: {ticker:<6} | Retorno Total: {final_return:.2f}%")

"""## Portfolio Cointegrado"""

def portf_download_data(start_date, end_date, candidate_stocks=None):
    # Lista de ativos candidatos, caso nenhum trio especifico seja informado
    if not candidate_stocks:
        candidate_stocks = [
            'ITUB4.SA', 'BBDC4.SA', 'BBAS3.SA', 'ITSA4.SA',
            'VALE3.SA', 'GGBR4.SA', 'GOAU4.SA',
            'PETR4.SA', 'PRIO3.SA', 'PETR3.SA',
            'ELET3.SA', 'CMIG4.SA', 'SBSP3.SA',
            'LREN3.SA', 'MGLU3.SA', 'WEGE3.SA'
        ]

    # Baixando todos os dados de uma vez para eficiência
    try:
        from datetime import datetime
        full_data = yf.download(candidate_stocks, start=start_date, end=end_date, progress=False)['Close']
        full_data.dropna(inplace=True)
    except Exception as e:
        print(f"Erro ao baixar os dados: {e}")
        exit()

    return full_data, candidate_stocks

def count_mean_crossings(spread):
    """
    Conta quantas vezes a série cruzou sua própria média.
    """
    mean = spread.mean()
    # Verifica onde o sinal da diferença (spread - média) muda
    crossings = np.sum(np.diff(np.sign(spread - mean)) != 0)
    return crossings

def johansen_test(full_data, candidate_stocks, validation_start_date):
    df = full_data[full_data.index < validation_start_date]
    test_result = coint_johansen(df, det_order=0, k_ar_diff=1)
    critical_value_95 = test_result.cvt[0, 1]
    trace_statistic = test_result.lr1[0]

    if trace_statistic > critical_value_95:
        print(f"O trio {candidate_stocks} possui cointegração no periodo definido")
        return True
    else:
        print(f"O trio {candidate_stocks} não possui cointegração no periodo definido")
        return False

def search_trio_candidates(candidate_stocks, full_data, start_date, end_date, validation_start_date):
    # BUSCA E SELEÇÃO DO TRIO (USANDO APENAS DADOS DE TREINO)
    print("Iniciando busca por trios com potencial de trading...")
    all_trios = list(itertools.combinations(candidate_stocks, 3))
    evaluated_trios = []

    # Baixando todos os dados de uma vez para eficiência
    try:
        from datetime import datetime
        full_data = yf.download(candidate_stocks, start=start_date, end=end_date, progress=False)['Close']
        full_data.dropna(inplace=True)
    except Exception as e:
        print(f"Erro ao baixar os dados: {e}")
        exit()

    # Separando os dados de treino para a busca
    df_train_search = full_data[full_data.index < validation_start_date]

    for trio in all_trios:
        symbols = list(trio)
        df = df_train_search[symbols].dropna()

        if len(df) < 100: continue

        try:
            # Passo 1: Verificar se o trio é cointegrado
            test_result = coint_johansen(df, det_order=0, k_ar_diff=1)
            critical_value_95 = test_result.cvt[0, 1]
            trace_statistic = test_result.lr1[0]

            if trace_statistic > critical_value_95:
                # Passo 2: Calcular as métricas de "tradabilidade"
                coint_vector = test_result.evec[:, 0]
                spread = df.dot(coint_vector)

                crossings = count_mean_crossings(spread)
                spread_std = spread.std()
                coint_score = trace_statistic / critical_value_95

                # Adicionamos todos os trios cointegrados para ranking
                evaluated_trios.append({
                    "trio": symbols,
                    "coint_score": coint_score,
                    "crossings": crossings,
                    "spread_std": spread_std
                })

        except (np.linalg.LinAlgError, ValueError): # Ignora erros de matriz singular ou outros problemas
            continue

    if not evaluated_trios:
        print("\nBusca concluída. Nenhum trio com características de trading foi encontrado.")
    else:
        # Passo 3: Criar um Ranking Combinado
        df_results = pd.DataFrame(evaluated_trios)

        # Criar rankings individuais (maior é melhor para score/crossings, menor é melhor para std)
        df_results['rank_score'] = df_results['coint_score'].rank(ascending=False)
        df_results['rank_crossings'] = df_results['crossings'].rank(ascending=False)
        df_results['rank_std'] = df_results['spread_std'].rank(ascending=True) # Menor desvio padrão é melhor

        # Ranking final é a soma dos rankings individuais
        df_results['final_rank'] = df_results['rank_score'] + df_results['rank_crossings'] + df_results['rank_std']

        # Ordenar pelo melhor ranking final (menor soma de ranks é melhor)
        df_results = df_results.sort_values(by='final_rank').reset_index(drop=True)

        print(f"\nBusca concluída. {len(df_results)} trios cointegrados encontrados e rankeados.")
        print("Top 5 melhores trios com base no ranking combinado:")
        print(df_results[['trio', 'coint_score', 'crossings', 'spread_std', 'final_rank']].head())

        # Selecionar o melhor trio
        best_trio_info = df_results.iloc[0]
        coint_symbols = best_trio_info['trio']

        print("-" * 50)
        print(f"\nTRIO SELECIONADO PARA BACKTEST: {coint_symbols}")
        print(f" (Score: {best_trio_info['coint_score']:.2f}, Cruzamentos: {best_trio_info['crossings']}, Volatilidade Spread: {best_trio_info['spread_std']:.4f})")
        print("-" * 50)

        # retorna trio escolhido
        return coint_symbols

def portf_visualize_results(coint_symbols, df_backtest, portf_acumm_return, start_validation_date, end_date, validation_spread, spread_mean, spread_std, signals, inferior_boundary, superior_boundary):
    # PREÇOS BRUTOS DOS ATIVOS
    fig, ax = plt.subplots(figsize=(15, 7))
    df_backtest.plot(ax=ax, linewidth=1.5)
    ax.set_title(f'Evolução dos Preços do Trio {coint_symbols} (Período de Validação)', fontsize=16)
    ax.set_xlabel('Data')
    ax.set_ylabel('Preço (R$)')
    ax.legend(title='Ativos')
    ax.grid(True, linestyle='--', alpha=0.6)
    ax.xaxis.set_major_locator(mdates.MonthLocator(interval=2))
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
    plt.setp(ax.get_xticklabels(), rotation=0, ha="right")
    plt.tight_layout()
    plt.show()

    # DIAGNÓSTICO DO SPREAD
    fig, ax1 = plt.subplots(figsize=(15, 7))
    ax1.plot(validation_spread.index, validation_spread, label='Spread de Validação', color='blue')
    ax1.axhline(spread_mean, color='black', linestyle='--', label=f'Média de Treino ({spread_mean:.2f})')
    ax1.axhline(superior_boundary, color='red', linestyle='--', label=f'Limite Superior ({superior_boundary:.2f})')
    ax1.axhline(inferior_boundary, color='green', linestyle='--', label=f'Limite Inferior ({inferior_boundary:.2f})')
    ax1.set_title(f'Diagnóstico do Spread para o Trio {coint_symbols}', fontsize=16)
    ax1.legend()
    ax1.set_xlim(df_backtest.index.min(), df_backtest.index.max()) # Define os limites
    ax1.xaxis.set_major_locator(mdates.MonthLocator(interval=1)) # Um marcador por mês
    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m')) # Formato Ano-Mês
    plt.setp(ax1.get_xticklabels(), rotation=0, ha="right") # Rotaciona para não sobrepor
    plt.tight_layout() # Ajusta o layout para caber os rótulos rotacionados
    plt.show()

    # RETORNO ACUMULADO
    plt.style.use('seaborn-v0_8-darkgrid')
    fig, ax2 = plt.subplots(figsize=(15, 7))
    (portf_acumm_return - 1).plot(ax=ax2, linewidth=2)
    ax2.yaxis.set_major_formatter(mtick.PercentFormatter(1.0))
    ax2.set_title(f'Retorno Acumulado da Estratégia Portfolio Cointegrado para o Trio {coint_symbols}', fontsize=16)
    ax2.axhline(0, color='black', linestyle='--', linewidth=0.8)
    final_percent_return = (portf_acumm_return.iloc[-1] - 1) * 100
    ax2.text(portf_acumm_return.index[-1], (portf_acumm_return.iloc[-1]-1), f' Retorno Final: {final_percent_return:.2f}%',
              verticalalignment='center', fontsize=12, weight='bold')
    ax2.set_xlim(df_backtest.index.min(), df_backtest.index.max()) # Define os limites
    ax2.xaxis.set_major_locator(mdates.MonthLocator(interval=1)) # Um marcador por mês
    ax2.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m')) # Formato Ano-Mês
    plt.setp(ax2.get_xticklabels(), rotation=0, ha="right") # Rotaciona para não sobrepor
    plt.tight_layout()
    plt.show()

    print(f"\nRetorno Total Acumulado da Estratégia {start_validation_date} -> {end_date}: {final_percent_return:.2f}%")
    num_trades = (signals['position'].diff() != 0).sum()
    print(f"Número de trades executados no período de validação: {num_trades}")

def portf_coint_backtest(backtest_trio, full_data, start_date, end_date, validation_start_date, visualize_results=False):
    # Carregar dados do trio selecionado para o período completo
    df_coint = full_data[backtest_trio].dropna()

    # Divisão dos dados em Período de Treinamento e Período de Validação
    df_train = df_coint[df_coint.index < validation_start_date]
    df_backtest = df_coint[df_coint.index >= validation_start_date]

    # Recalcular os parâmetros do modelo APENAS com os dados de treino do trio selecionado
    johansen_result = coint_johansen(df_train, det_order=0, k_ar_diff=1)
    coint_vector = johansen_result.evec[:, 0]

    train_spread = df_train.dot(coint_vector)
    spread_mean = train_spread.mean()
    spread_std = train_spread.std()

    lim_factor = 1.5 # Fator do desvio padrão para os limites
    superior_boundary = spread_mean + lim_factor * spread_std
    inferior_boundary = spread_mean - lim_factor * spread_std

    # Validação do Modelo (Backtesting)
    validation_spread = df_backtest.dot(coint_vector)
    signals = pd.DataFrame(index=df_backtest.index)
    signals['portfolio_price'] = validation_spread
    signals['signal'] = 0
    signals.loc[signals['portfolio_price'] > superior_boundary, 'signal'] = -1
    signals.loc[signals['portfolio_price'] < inferior_boundary, 'signal'] = 1
    signals['position'] = signals['signal'].replace(0, np.nan).ffill().fillna(0)

    # Calcular os retornos diários dos ativos individuais no período de backtest
    single_returns = df_backtest.pct_change()

    # 2. Calcular o retorno diário bruto do portfólio (spread)
    #    Isso é o produto escalar dos retornos individuais pelo vetor de cointegração.
    #    O sinal do coint_vector determina se estamos comprados ou vendidos em cada ativo.
    portfolio_raw_return = single_returns.dot(coint_vector)

    # 3. O retorno da estratégia é o retorno bruto do portfólio multiplicado pela posição do dia anterior.
    #    Usamos signals['position'].shift(1) para evitar lookahead bias.
    #    O sinal da posição já nos diz se estamos comprados (+1) ou vendidos (-1) no spread.
    estrategy_return = (portfolio_raw_return * signals['position'].shift(1)).fillna(0)

    # 4. Calcular o retorno acumulado da forma correta
    portf_acumm_return = (1 + estrategy_return).cumprod()

    if visualize_results:
        portf_visualize_results(backtest_trio, df_backtest, portf_acumm_return, validation_start_date, end_date, validation_spread, spread_mean, spread_std, signals, inferior_boundary, superior_boundary)

    return df_backtest, portf_acumm_return

from statsmodels.tsa.vector_ar.vecm import coint_johansen
import itertools
import matplotlib.ticker as mtick
import matplotlib.dates as mdates

start_date = "2010-01-01"
end_date = "2021-12-31"
validation_start_date = "2021-01-01"

"""### Backtest para trio PETROBRAS, VALE e WEG"""

candidate_stocks = ['PETR3.SA', 'VALE3.SA', 'WEGE3.SA']
full_data, candidate_stocks = portf_download_data(start_date, end_date, candidate_stocks)
johansen_test(full_data, candidate_stocks, validation_start_date)
chosen_trio = candidate_stocks
portf_backtest, portf_accum_return = portf_coint_backtest(chosen_trio, full_data, start_date, end_date, validation_start_date, visualize_results=True)

"""### Backtest para trio NVIDIA, INTEL e AMD"""

candidate_stocks = ['INTC', 'NVDA', 'AMD']
full_data, candidate_stocks = portf_download_data(start_date, end_date, candidate_stocks)
johansen_test(full_data, candidate_stocks, validation_start_date)
chosen_trio = candidate_stocks
portf_backtest, portf_accum_return = portf_coint_backtest(chosen_trio, full_data, start_date, end_date, validation_start_date, visualize_results=True)

"""## Análises por janelas **temporais**"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

def analisar_retornos(df_garch_backtest,
                      tipo="yearly", start_date="2010-01-01", end_date="2021-12-31"):
    """
    Analisa e plota os retornos acumulados das estratégias Heston, GARCH e Portfolio
    em janelas fixas (yearly/monthly) ou contínuas (rolling).
    """

    # --- Função auxiliar para janelas fixas ---
    def analyze_period_windows(df, window_type="yearly"):
        result = []
        if window_type == "yearly":
            group_keys = df.index.to_period("Y")
        elif window_type == "monthly":
            group_keys = df.index.to_period("M")
        else:
            raise ValueError("window_type deve ser 'yearly' ou 'monthly'")

        for period in sorted(set(group_keys)):
            df_period = df[group_keys == period]
            if len(df_period) < 10:
                continue
            final = df_period.iloc[-1]
            initial = df_period.iloc[0]
            returns = final - initial
            result.append({"Período": str(period), **returns.to_dict()})

        return pd.DataFrame(result)

    # --- Verificações iniciais ---
    # if 'Skill_Equity_Curve' not in df_heston_backtest.columns:
    #     print("❌ 'Skill_Equity_Curve' não encontrado em df_heston_backtest.")
    #     return
    if 'GARCH_Equity_Curve' not in df_garch_backtest.columns:
        print("❌ 'GARCH_Equity_Curve' não encontrado em df_garch_backtest.")
        return


    # --- Construção das curvas de retorno acumulado ---
    equity_curves = pd.DataFrame({
        #'Heston': df_heston_backtest['Skill_Equity_Curve'],
        'GARCH': df_garch_backtest['GARCH_Equity_Curve'],

    })

    # Alinhar datas comuns
    common_index = equity_curves.dropna().index
    equity_curves = equity_curves.reindex(common_index).ffill().dropna()

    # Recorte de datas
    equity_curves_analysis = equity_curves.loc[start_date:end_date].copy()
    if equity_curves_analysis.empty:
        print(f"❌ Sem dados entre {start_date} e {end_date}")
        return

    # --- Análise por tipo ---
    if tipo in ["yearly", "monthly"]:
        df_period_analysis = analyze_period_windows(equity_curves_analysis, window_type=tipo)
        print(f"\n🔍 Retornos por {tipo.capitalize()} de {start_date} a {end_date}:")
        print(df_period_analysis)

        # Plot de barras
        df_period_analysis.set_index("Período").plot(kind="bar", figsize=(14, 6))
        plt.title(f"Retorno por {tipo.capitalize()} das Estratégias ({start_date} a {end_date})")
        plt.ylabel("Retorno")
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.show()

    elif tipo == "rolling":
        print(f"\n📈 Retorno acumulado de {start_date} a {end_date}:")
        equity_curves_analysis.plot(figsize=(14, 6))
        plt.title(f"Retorno Acumulado das Estratégias ({start_date} a {end_date})")
        plt.xlabel("Data")
        plt.ylabel("Retorno Acumulado")
        plt.grid(True)
        plt.tight_layout()
        plt.legend()
        plt.show()

    else:
        print("❌ Tipo inválido. Use 'yearly', 'monthly' ou 'rolling'.")

analisar_retornos(
    #df_heston_backtest=aux, # Use the distinct Heston results dataframe
    df_garch_backtest=df_garch_backtest,  # Use the distinct GARCH results dataframe
    #df_portf_backtest=portf_accum_return, # Use the Portfolio accumulated return
    tipo="rolling",  # or "yearly", "monthly", "rolling"
    start_date="2010-01-01",
    end_date="2021-12-31" # Adjust dates as needed
)